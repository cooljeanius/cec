/* Automatically generated by AST.sh -- do not edit */
#include "AST.hpp"
namespace AST {



  void ASTNode::read(XMListream &r) {
    Node::read(r); 
  }

  void ASTNode::write(XMLostream &w) const {
    Node::write(w); 
  }

  
  

  void Symbol::read(XMListream &r) {
    ASTNode::read(r); 
    r >> name;
  }

  void Symbol::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << name;
  }

  
  

  void ModuleSymbol::read(XMListream &r) {
    Symbol::read(r); 
    r >> module;
  }

  void ModuleSymbol::write(XMLostream &w) const {
    Symbol::write(w); 
    w << module;
  }

  IRCLASS(ModuleSymbol);
  Status ModuleSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ValuedSymbol::read(XMListream &r) {
    Symbol::read(r); 
    r >> type >> initializer;
  }

  void ValuedSymbol::write(XMLostream &w) const {
    Symbol::write(w); 
    w << type << initializer;
  }

  
  

  void VariableSymbol::read(XMListream &r) {
    ValuedSymbol::read(r); 
  }

  void VariableSymbol::write(XMLostream &w) const {
    ValuedSymbol::write(w); 
  }

  IRCLASS(VariableSymbol);
  Status VariableSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ConstantSymbol::read(XMListream &r) {
    VariableSymbol::read(r); 
  }

  void ConstantSymbol::write(XMLostream &w) const {
    VariableSymbol::write(w); 
  }

  IRCLASS(ConstantSymbol);
  Status ConstantSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void BuiltinConstantSymbol::read(XMListream &r) {
    ConstantSymbol::read(r); 
  }

  void BuiltinConstantSymbol::write(XMLostream &w) const {
    ConstantSymbol::write(w); 
  }

  IRCLASS(BuiltinConstantSymbol);
  Status BuiltinConstantSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void SignalSymbol::read(XMListream &r) {
    ValuedSymbol::read(r); 
    r >> kind >> combine >> reincarnation;
  }

  void SignalSymbol::write(XMLostream &w) const {
    ValuedSymbol::write(w); 
    w << kind << combine << reincarnation;
  }

  IRCLASS(SignalSymbol);
  Status SignalSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void BuiltinSignalSymbol::read(XMListream &r) {
    SignalSymbol::read(r); 
  }

  void BuiltinSignalSymbol::write(XMLostream &w) const {
    SignalSymbol::write(w); 
  }

  IRCLASS(BuiltinSignalSymbol);
  Status BuiltinSignalSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void TypeSymbol::read(XMListream &r) {
    Symbol::read(r); 
  }

  void TypeSymbol::write(XMLostream &w) const {
    Symbol::write(w); 
  }

  IRCLASS(TypeSymbol);
  Status TypeSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void BuiltinTypeSymbol::read(XMListream &r) {
    TypeSymbol::read(r); 
  }

  void BuiltinTypeSymbol::write(XMLostream &w) const {
    TypeSymbol::write(w); 
  }

  IRCLASS(BuiltinTypeSymbol);
  Status BuiltinTypeSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void FunctionSymbol::read(XMListream &r) {
    TypeSymbol::read(r); 
    r >> arguments >> result;
  }

  void FunctionSymbol::write(XMLostream &w) const {
    TypeSymbol::write(w); 
    w << arguments << result;
  }

  IRCLASS(FunctionSymbol);
  Status FunctionSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void BuiltinFunctionSymbol::read(XMListream &r) {
    FunctionSymbol::read(r); 
  }

  void BuiltinFunctionSymbol::write(XMLostream &w) const {
    FunctionSymbol::write(w); 
  }

  IRCLASS(BuiltinFunctionSymbol);
  Status BuiltinFunctionSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ProcedureSymbol::read(XMListream &r) {
    TypeSymbol::read(r); 
    r >> reference_arguments >> value_arguments;
  }

  void ProcedureSymbol::write(XMLostream &w) const {
    TypeSymbol::write(w); 
    w << reference_arguments << value_arguments;
  }

  IRCLASS(ProcedureSymbol);
  Status ProcedureSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void TaskSymbol::read(XMListream &r) {
    ProcedureSymbol::read(r); 
  }

  void TaskSymbol::write(XMLostream &w) const {
    ProcedureSymbol::write(w); 
  }

  IRCLASS(TaskSymbol);
  Status TaskSymbol::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void SymbolTable::read(XMListream &r) {
    ASTNode::read(r); 
    r >> parent >> symbols;
  }

  void SymbolTable::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << parent << symbols;
  }

  IRCLASS(SymbolTable);
  Status SymbolTable::welcome(Visitor &v) { return v.visit(*this); }
  
bool SymbolTable::local_contains(const string s) const {
  for ( stvec::const_iterator i = symbols.begin() ; i != symbols.end() ; i++ ) {
    assert(*i);
    if ( (*i)->name == s) return true;
  }
  return false;
}

bool SymbolTable::contains(const string s) const {
  for ( const SymbolTable *st = this ; st ; st = st->parent )
    if (st->local_contains(s)) return true;
  return false;
}

void SymbolTable::enter(Symbol *sym) {
  assert(sym);
  assert(!local_contains(sym->name));
  symbols.push_back( sym );
}

Symbol* SymbolTable::get(const string s) {
  for ( SymbolTable *st = this; st ; st = st->parent ) {
    for ( const_iterator i = st->begin() ; i != st->end() ; i++ )
      if ( (*i)->name == s) return *i;
  }
  assert(0); // get should not be called unless contains returned true
}

  

  void Expression::read(XMListream &r) {
    ASTNode::read(r); 
    r >> type;
  }

  void Expression::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << type;
  }

  
  

  void Literal::read(XMListream &r) {
    Expression::read(r); 
    r >> value;
  }

  void Literal::write(XMLostream &w) const {
    Expression::write(w); 
    w << value;
  }

  IRCLASS(Literal);
  Status Literal::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void LoadVariableExpression::read(XMListream &r) {
    Expression::read(r); 
    r >> variable;
  }

  void LoadVariableExpression::write(XMLostream &w) const {
    Expression::write(w); 
    w << variable;
  }

  IRCLASS(LoadVariableExpression);
  Status LoadVariableExpression::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void LoadSignalExpression::read(XMListream &r) {
    Expression::read(r); 
    r >> signal;
  }

  void LoadSignalExpression::write(XMLostream &w) const {
    Expression::write(w); 
    w << signal;
  }

  IRCLASS(LoadSignalExpression);
  Status LoadSignalExpression::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void LoadSignalValueExpression::read(XMListream &r) {
    Expression::read(r); 
    r >> signal;
  }

  void LoadSignalValueExpression::write(XMLostream &w) const {
    Expression::write(w); 
    w << signal;
  }

  IRCLASS(LoadSignalValueExpression);
  Status LoadSignalValueExpression::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void UnaryOp::read(XMListream &r) {
    Expression::read(r); 
    r >> op >> source;
  }

  void UnaryOp::write(XMLostream &w) const {
    Expression::write(w); 
    w << op << source;
  }

  IRCLASS(UnaryOp);
  Status UnaryOp::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void BinaryOp::read(XMListream &r) {
    Expression::read(r); 
    r >> op >> source1 >> source2;
  }

  void BinaryOp::write(XMLostream &w) const {
    Expression::write(w); 
    w << op << source1 << source2;
  }

  IRCLASS(BinaryOp);
  Status BinaryOp::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void FunctionCall::read(XMListream &r) {
    Expression::read(r); 
    r >> callee >> arguments;
  }

  void FunctionCall::write(XMLostream &w) const {
    Expression::write(w); 
    w << callee << arguments;
  }

  IRCLASS(FunctionCall);
  Status FunctionCall::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Delay::read(XMListream &r) {
    Expression::read(r); 
    r >> predicate >> count >> is_immediate >> counter;
  }

  void Delay::write(XMLostream &w) const {
    Expression::write(w); 
    w << predicate << count << is_immediate << counter;
  }

  IRCLASS(Delay);
  Status Delay::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void CheckCounter::read(XMListream &r) {
    Expression::read(r); 
    r >> counter >> predicate;
  }

  void CheckCounter::write(XMLostream &w) const {
    Expression::write(w); 
    w << counter << predicate;
  }

  IRCLASS(CheckCounter);
  Status CheckCounter::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Module::read(XMListream &r) {
    ASTNode::read(r); 
    r >> symbol >> types >> constants >> functions >> procedures >> tasks >> signals >> variables >> counters >> relations >> body;
  }

  void Module::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << symbol << types << constants << functions << procedures << tasks << signals << variables << counters << relations << body;
  }

  IRCLASS(Module);
  Status Module::welcome(Visitor &v) { return v.visit(*this); }
  
Module::Module(ModuleSymbol *s) : symbol(s), body(NULL) {
  signals = new SymbolTable();
  constants = new SymbolTable();
  types = new SymbolTable();
  functions = new SymbolTable();
  procedures = new SymbolTable();
  tasks = new SymbolTable();
  variables = new SymbolTable();
}

Module::~Module() {
   delete signals;
   delete types;
   delete constants;
   delete functions;
   delete procedures;
   delete tasks;
   delete body;
   delete variables;
}
  

  void InputRelation::read(XMListream &r) {
    ASTNode::read(r); 
  }

  void InputRelation::write(XMLostream &w) const {
    ASTNode::write(w); 
  }

  
  

  void Exclusion::read(XMListream &r) {
    InputRelation::read(r); 
    r >> signals;
  }

  void Exclusion::write(XMLostream &w) const {
    InputRelation::write(w); 
    w << signals;
  }

  IRCLASS(Exclusion);
  Status Exclusion::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Implication::read(XMListream &r) {
    InputRelation::read(r); 
    r >> predicate >> implication;
  }

  void Implication::write(XMLostream &w) const {
    InputRelation::write(w); 
    w << predicate << implication;
  }

  IRCLASS(Implication);
  Status Implication::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Counter::read(XMListream &r) {
    ASTNode::read(r); 
  }

  void Counter::write(XMLostream &w) const {
    ASTNode::write(w); 
  }

  IRCLASS(Counter);
  Status Counter::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Modules::read(XMListream &r) {
    ASTNode::read(r); 
    r >> module_symbols >> modules;
  }

  void Modules::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << module_symbols << modules;
  }

  IRCLASS(Modules);
  Status Modules::welcome(Visitor &v) { return v.visit(*this); }
  
void Modules::add(Module* m) {
  assert(m);
  assert(m->symbol);
  assert(!module_symbols.contains(m->symbol->name));
  modules.push_back(m);
  module_symbols.enter(m->symbol);
}
  

  void Statement::read(XMListream &r) {
    ASTNode::read(r); 
  }

  void Statement::write(XMLostream &w) const {
    ASTNode::write(w); 
  }

  
  

  void BodyStatement::read(XMListream &r) {
    Statement::read(r); 
    r >> body;
  }

  void BodyStatement::write(XMLostream &w) const {
    Statement::write(w); 
    w << body;
  }

  
  

  void PredicatedStatement::read(XMListream &r) {
    BodyStatement::read(r); 
    r >> predicate;
  }

  void PredicatedStatement::write(XMLostream &w) const {
    BodyStatement::write(w); 
    w << predicate;
  }

  IRCLASS(PredicatedStatement);
  Status PredicatedStatement::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void CaseStatement::read(XMListream &r) {
    Statement::read(r); 
    r >> cases >> default_stmt;
  }

  void CaseStatement::write(XMLostream &w) const {
    Statement::write(w); 
    w << cases << default_stmt;
  }

  
  

  void StatementList::read(XMListream &r) {
    Statement::read(r); 
    r >> statements;
  }

  void StatementList::write(XMLostream &w) const {
    Statement::write(w); 
    w << statements;
  }

  IRCLASS(StatementList);
  Status StatementList::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ParallelStatementList::read(XMListream &r) {
    Statement ::read(r); 
    r >> threads;
  }

  void ParallelStatementList::write(XMLostream &w) const {
    Statement ::write(w); 
    w << threads;
  }

  IRCLASS(ParallelStatementList);
  Status ParallelStatementList::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Nothing::read(XMListream &r) {
    Statement::read(r); 
  }

  void Nothing::write(XMLostream &w) const {
    Statement::write(w); 
  }

  IRCLASS(Nothing);
  Status Nothing::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Pause::read(XMListream &r) {
    Statement::read(r); 
  }

  void Pause::write(XMLostream &w) const {
    Statement::write(w); 
  }

  IRCLASS(Pause);
  Status Pause::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Halt::read(XMListream &r) {
    Statement::read(r); 
  }

  void Halt::write(XMLostream &w) const {
    Statement::write(w); 
  }

  IRCLASS(Halt);
  Status Halt::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Emit::read(XMListream &r) {
    Statement::read(r); 
    r >> signal >> value >> unknown;
  }

  void Emit::write(XMLostream &w) const {
    Statement::write(w); 
    w << signal << value << unknown;
  }

  IRCLASS(Emit);
  Status Emit::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Exit::read(XMListream &r) {
    Statement::read(r); 
    r >> trap >> value;
  }

  void Exit::write(XMLostream &w) const {
    Statement::write(w); 
    w << trap << value;
  }

  IRCLASS(Exit);
  Status Exit::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Sustain::read(XMListream &r) {
    Emit::read(r); 
  }

  void Sustain::write(XMLostream &w) const {
    Emit::write(w); 
  }

  IRCLASS(Sustain);
  Status Sustain::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Assign::read(XMListream &r) {
    Statement::read(r); 
    r >> variable >> value;
  }

  void Assign::write(XMLostream &w) const {
    Statement::write(w); 
    w << variable << value;
  }

  IRCLASS(Assign);
  Status Assign::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ProcedureCall::read(XMListream &r) {
    Statement::read(r); 
    r >> procedure >> reference_args >> value_args;
  }

  void ProcedureCall::write(XMLostream &w) const {
    Statement::write(w); 
    w << procedure << reference_args << value_args;
  }

  IRCLASS(ProcedureCall);
  Status ProcedureCall::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Present::read(XMListream &r) {
    CaseStatement::read(r); 
  }

  void Present::write(XMLostream &w) const {
    CaseStatement::write(w); 
  }

  IRCLASS(Present);
  Status Present::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void If::read(XMListream &r) {
    CaseStatement::read(r); 
  }

  void If::write(XMLostream &w) const {
    CaseStatement::write(w); 
  }

  IRCLASS(If);
  Status If::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Loop::read(XMListream &r) {
    BodyStatement::read(r); 
  }

  void Loop::write(XMLostream &w) const {
    BodyStatement::write(w); 
  }

  IRCLASS(Loop);
  Status Loop::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Repeat::read(XMListream &r) {
    Loop::read(r); 
    r >> count >> is_positive >> counter;
  }

  void Repeat::write(XMLostream &w) const {
    Loop::write(w); 
    w << count << is_positive << counter;
  }

  IRCLASS(Repeat);
  Status Repeat::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Abort::read(XMListream &r) {
    CaseStatement::read(r); 
    r >> body >> is_weak;
  }

  void Abort::write(XMLostream &w) const {
    CaseStatement::write(w); 
    w << body << is_weak;
  }

  IRCLASS(Abort);
  Status Abort::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Await::read(XMListream &r) {
    CaseStatement::read(r); 
  }

  void Await::write(XMLostream &w) const {
    CaseStatement::write(w); 
  }

  IRCLASS(Await);
  Status Await::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void LoopEach::read(XMListream &r) {
    PredicatedStatement::read(r); 
  }

  void LoopEach::write(XMLostream &w) const {
    PredicatedStatement::write(w); 
  }

  IRCLASS(LoopEach);
  Status LoopEach::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Every::read(XMListream &r) {
    PredicatedStatement::read(r); 
  }

  void Every::write(XMLostream &w) const {
    PredicatedStatement::write(w); 
  }

  IRCLASS(Every);
  Status Every::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Suspend::read(XMListream &r) {
    PredicatedStatement::read(r); 
  }

  void Suspend::write(XMLostream &w) const {
    PredicatedStatement::write(w); 
  }

  IRCLASS(Suspend);
  Status Suspend::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void DoWatching::read(XMListream &r) {
    PredicatedStatement::read(r); 
    r >> timeout;
  }

  void DoWatching::write(XMLostream &w) const {
    PredicatedStatement::write(w); 
    w << timeout;
  }

  IRCLASS(DoWatching);
  Status DoWatching::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void DoUpto::read(XMListream &r) {
    PredicatedStatement::read(r); 
  }

  void DoUpto::write(XMLostream &w) const {
    PredicatedStatement::write(w); 
  }

  IRCLASS(DoUpto);
  Status DoUpto::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void TaskCall::read(XMListream &r) {
    ProcedureCall::read(r); 
    r >> signal >> body;
  }

  void TaskCall::write(XMLostream &w) const {
    ProcedureCall::write(w); 
    w << signal << body;
  }

  IRCLASS(TaskCall);
  Status TaskCall::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Exec::read(XMListream &r) {
    Statement::read(r); 
    r >> calls;
  }

  void Exec::write(XMLostream &w) const {
    Statement::write(w); 
    w << calls;
  }

  IRCLASS(Exec);
  Status Exec::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ScopeStatement::read(XMListream &r) {
    BodyStatement::read(r); 
    r >> symbols;
  }

  void ScopeStatement::write(XMLostream &w) const {
    BodyStatement::write(w); 
    w << symbols;
  }

  
  

  void Trap::read(XMListream &r) {
    ScopeStatement::read(r); 
    r >> handlers;
  }

  void Trap::write(XMLostream &w) const {
    ScopeStatement::write(w); 
    w << handlers;
  }

  IRCLASS(Trap);
  Status Trap::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Signal::read(XMListream &r) {
    ScopeStatement::read(r); 
  }

  void Signal::write(XMLostream &w) const {
    ScopeStatement::write(w); 
  }

  IRCLASS(Signal);
  Status Signal::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Var::read(XMListream &r) {
    ScopeStatement::read(r); 
  }

  void Var::write(XMLostream &w) const {
    ScopeStatement::write(w); 
  }

  IRCLASS(Var);
  Status Var::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void StartCounter::read(XMListream &r) {
    Statement::read(r); 
    r >> counter >> count;
  }

  void StartCounter::write(XMLostream &w) const {
    Statement::write(w); 
    w << counter << count;
  }

  IRCLASS(StartCounter);
  Status StartCounter::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Renaming::read(XMListream &r) {
    ASTNode::read(r); 
    r >> old_name;
  }

  void Renaming::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << old_name;
  }

  
  

  void TypeRenaming::read(XMListream &r) {
    Renaming::read(r); 
    r >> new_type;
  }

  void TypeRenaming::write(XMLostream &w) const {
    Renaming::write(w); 
    w << new_type;
  }

  IRCLASS(TypeRenaming);
  Status TypeRenaming::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ConstantRenaming::read(XMListream &r) {
    Renaming::read(r); 
    r >> new_value;
  }

  void ConstantRenaming::write(XMLostream &w) const {
    Renaming::write(w); 
    w << new_value;
  }

  IRCLASS(ConstantRenaming);
  Status ConstantRenaming::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void FunctionRenaming::read(XMListream &r) {
    Renaming::read(r); 
    r >> new_func;
  }

  void FunctionRenaming::write(XMLostream &w) const {
    Renaming::write(w); 
    w << new_func;
  }

  IRCLASS(FunctionRenaming);
  Status FunctionRenaming::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ProcedureRenaming::read(XMListream &r) {
    Renaming::read(r); 
    r >> new_proc;
  }

  void ProcedureRenaming::write(XMLostream &w) const {
    Renaming::write(w); 
    w << new_proc;
  }

  IRCLASS(ProcedureRenaming);
  Status ProcedureRenaming::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void SignalRenaming::read(XMListream &r) {
    Renaming::read(r); 
    r >> new_sig;
  }

  void SignalRenaming::write(XMLostream &w) const {
    Renaming::write(w); 
    w << new_sig;
  }

  IRCLASS(SignalRenaming);
  Status SignalRenaming::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Run::read(XMListream &r) {
    Statement::read(r); 
    r >> old_name >> new_name >> types >> constants >> functions >> procedures >> tasks >> signals >> signalScope;
  }

  void Run::write(XMLostream &w) const {
    Statement::write(w); 
    w << old_name << new_name << types << constants << functions << procedures << tasks << signals << signalScope;
  }

  IRCLASS(Run);
  Status Run::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void IfThenElse::read(XMListream &r) {
    Statement::read(r); 
    r >> predicate >> then_part >> else_part;
  }

  void IfThenElse::write(XMLostream &w) const {
    Statement::write(w); 
    w << predicate << then_part << else_part;
  }

  IRCLASS(IfThenElse);
  Status IfThenElse::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void GRCNode::read(XMListream &r) {
    ASTNode::read(r); 
    r >> predecessors >> successors >> dataPredecessors >> dataSuccessors;
  }

  void GRCNode::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << predecessors << successors << dataPredecessors << dataSuccessors;
  }

  
  GRCNode& GRCNode::operator >>(GRCNode *s) {
    successors.push_back(s);
    if (s) s->predecessors.push_back(this);
    return *this;
  }

  GRCNode& GRCNode::operator <<(GRCNode *p) {
    assert(p);
    dataPredecessors.push_back(p);
    p->dataSuccessors.push_back(this);
    return *this;
  }

  int GRCNode::enumerate(NumMap &number, std::set<GRCNode *> &visited, int next) {
    
    if (visited.find(this) != visited.end()) return next;
    visited.insert(this);
    if (number.find(this) == number.end() || number[this] == 0) {
      number[this] = next++;
    }
    for (vector<GRCNode*>::const_iterator i = successors.begin();
          i != successors.end() ; i++)
                if (*i) next = (*i)->enumerate(number, visited, next);
    for (vector<GRCNode*>::const_iterator i = predecessors.begin();
           i != predecessors.end() ; i++)
                if(*i) next = (*i)->enumerate(number, visited, next);
    for (vector<GRCNode*>::const_iterator i = dataSuccessors.begin();
           i != dataSuccessors.end() ; i++)
                if(*i) next = (*i)->enumerate(number, visited, next);
    for (vector<GRCNode*>::const_iterator i = dataPredecessors.begin();
           i != dataPredecessors.end() ; i++)
                if(*i) next = (*i)->enumerate(number, visited, next);      
    return next;
  }

  

  void GRCSTNode::read(XMListream &r) {
    GRCNode::read(r); 
    r >> st;
  }

  void GRCSTNode::write(XMLostream &w) const {
    GRCNode::write(w); 
    w << st;
  }

  
  

  void EnterGRC::read(XMListream &r) {
    GRCNode::read(r); 
  }

  void EnterGRC::write(XMLostream &w) const {
    GRCNode::write(w); 
  }

  IRCLASS(EnterGRC);
  Status EnterGRC::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void ExitGRC::read(XMListream &r) {
    GRCNode::read(r); 
  }

  void ExitGRC::write(XMLostream &w) const {
    GRCNode::write(w); 
  }

  IRCLASS(ExitGRC);
  Status ExitGRC::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Nop::read(XMListream &r) {
    GRCNode::read(r); 
    r >> type >> code >> body;
  }

  void Nop::write(XMLostream &w) const {
    GRCNode::write(w); 
    w << type << code << body;
  }

  IRCLASS(Nop);
  Status Nop::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void DefineSignal::read(XMListream &r) {
    GRCNode::read(r); 
    r >> signal >> is_surface;
  }

  void DefineSignal::write(XMLostream &w) const {
    GRCNode::write(w); 
    w << signal << is_surface;
  }

  IRCLASS(DefineSignal);
  Status DefineSignal::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Switch::read(XMListream &r) {
    GRCSTNode::read(r); 
  }

  void Switch::write(XMLostream &w) const {
    GRCSTNode::write(w); 
  }

  IRCLASS(Switch);
  Status Switch::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Test::read(XMListream &r) {
    GRCSTNode::read(r); 
    r >> predicate;
  }

  void Test::write(XMLostream &w) const {
    GRCSTNode::write(w); 
    w << predicate;
  }

  IRCLASS(Test);
  Status Test::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void STSuspend::read(XMListream &r) {
    GRCSTNode::read(r); 
  }

  void STSuspend::write(XMLostream &w) const {
    GRCSTNode::write(w); 
  }

  IRCLASS(STSuspend);
  Status STSuspend::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Fork::read(XMListream &r) {
    GRCNode::read(r); 
    r >> sync;
  }

  void Fork::write(XMLostream &w) const {
    GRCNode::write(w); 
    w << sync;
  }

  IRCLASS(Fork);
  Status Fork::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Sync::read(XMListream &r) {
    GRCSTNode::read(r); 
  }

  void Sync::write(XMLostream &w) const {
    GRCSTNode::write(w); 
  }

  IRCLASS(Sync);
  Status Sync::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Terminate::read(XMListream &r) {
    GRCNode::read(r); 
    r >> code >> index;
  }

  void Terminate::write(XMLostream &w) const {
    GRCNode::write(w); 
    w << code << index;
  }

  IRCLASS(Terminate);
  Status Terminate::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Action::read(XMListream &r) {
    GRCNode::read(r); 
    r >> body;
  }

  void Action::write(XMLostream &w) const {
    GRCNode::write(w); 
    w << body;
  }

  IRCLASS(Action);
  Status Action::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void Enter::read(XMListream &r) {
    GRCSTNode::read(r); 
  }

  void Enter::write(XMLostream &w) const {
    GRCSTNode::write(w); 
  }

  IRCLASS(Enter);
  Status Enter::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void STNode::read(XMListream &r) {
    ASTNode::read(r); 
    r >> parent >> children;
  }

  void STNode::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << parent << children;
  }

  
  STNode& STNode::operator >>(STNode *s) {
//    assert(s);
    children.push_back(s);
    if(s) s->parent = this;
    return *this;
  }

  int STNode::enumerate(NumMap &number, std::set<STNode*> &visited, int next) {
    if(visited.find(this) != visited.end()) return next;
    visited.insert(this);

    if(number.find(this) == number.end() || number[this] == 0){
        number[this] = next++;
    }
    for (vector<STNode*>::const_iterator i = children.begin() ;
         i != children.end() ; i++) if(*i)
      next = (*i)->enumerate(number, visited,  next);
    return next;
  }

  

  void STexcl::read(XMListream &r) {
    STNode::read(r); 
  }

  void STexcl::write(XMLostream &w) const {
    STNode::write(w); 
  }

  IRCLASS(STexcl);
  Status STexcl::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void STpar::read(XMListream &r) {
    STNode::read(r); 
  }

  void STpar::write(XMLostream &w) const {
    STNode::write(w); 
  }

  IRCLASS(STpar);
  Status STpar::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void STref::read(XMListream &r) {
    STNode::read(r); 
    r >> type;
  }

  void STref::write(XMLostream &w) const {
    STNode::write(w); 
    w << type;
  }

  IRCLASS(STref);
  Status STref::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void STleaf::read(XMListream &r) {
    STNode::read(r); 
    r >> type;
  }

  void STleaf::write(XMLostream &w) const {
    STNode::write(w); 
    w << type;
  }

  IRCLASS(STleaf);
  Status STleaf::welcome(Visitor &v) { return v.visit(*this); }
  
  

  void GRCgraph::read(XMListream &r) {
    ASTNode::read(r); 
    r >> selection_tree >> control_flow_graph;
  }

  void GRCgraph::write(XMLostream &w) const {
    ASTNode::write(w); 
    w << selection_tree << control_flow_graph;
  }

  IRCLASS(GRCgraph);
  Status GRCgraph::welcome(Visitor &v) { return v.visit(*this); }
  
 int GRCgraph::enumerate(GRCNode::NumMap &cfgmap, STNode::NumMap &stmap, int max)
{
  std::set<GRCNode*> cfg_visited;
  std::set<STNode*>   st_visited;

  assert(selection_tree);
  assert(control_flow_graph);

  max = selection_tree->enumerate(stmap, st_visited, max);
  max = control_flow_graph->enumerate(cfgmap, cfg_visited, max);
  return max;
}


  

}

