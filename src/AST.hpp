#ifndef _AST_HPP
#  define _AST_HPP

/* Automatically generated by AST.sh -- do not edit */

#  include "IR.hpp"
#  include <string>
#  include <vector>
#  include <map>
#  include <cassert>
#  include <set>

namespace AST {
  using IR::Node;
  using IR::XMListream;
  using IR::XMLostream;
  using std::string;
  using std::vector;
  using std::map;

  class Visitor;

  class ASTNode;
  class Symbol;
  class ModuleSymbol;
  class ValuedSymbol;
  class VariableSymbol;
  class ConstantSymbol;
  class BuiltinConstantSymbol;
  class SignalSymbol;
  class BuiltinSignalSymbol;
  class TypeSymbol;
  class BuiltinTypeSymbol;
  class FunctionSymbol;
  class BuiltinFunctionSymbol;
  class ProcedureSymbol;
  class TaskSymbol;
  class SymbolTable;
  class Expression;
  class Literal;
  class LoadVariableExpression;
  class LoadSignalExpression;
  class LoadSignalValueExpression;
  class UnaryOp;
  class BinaryOp;
  class FunctionCall;
  class Delay;
  class CheckCounter;
  class Module;
  class InputRelation;
  class Exclusion;
  class Implication;
  class Counter;
  class Modules;
  class Statement;
  class BodyStatement;
  class PredicatedStatement;
  class CaseStatement;
  class StatementList;
  class ParallelStatementList;
  class Nothing;
  class Pause;
  class Halt;
  class Emit;
  class Exit;
  class Sustain;
  class Assign;
  class ProcedureCall;
  class Present;
  class If;
  class Loop;
  class Repeat;
  class Abort;
  class Await;
  class LoopEach;
  class Every;
  class Suspend;
  class DoWatching;
  class DoUpto;
  class TaskCall;
  class Exec;
  class ScopeStatement;
  class Trap;
  class Signal;
  class Var;
  class StartCounter;
  class Renaming;
  class TypeRenaming;
  class ConstantRenaming;
  class FunctionRenaming;
  class ProcedureRenaming;
  class SignalRenaming;
  class Run;
  class IfThenElse;
  class GRCNode;
  class GRCSTNode;
  class EnterGRC;
  class ExitGRC;
  class Nop;
  class DefineSignal;
  class Switch;
  class Test;
  class STSuspend;
  class Fork;
  class Sync;
  class Terminate;
  class Action;
  class Enter;
  class STNode;
  class STexcl;
  class STpar;
  class STref;
  class STleaf;
  class GRCgraph;

  union Status {
    int i;
    ASTNode *n;
    Status() : n(0) {}
    Status(int ii) : i(ii) {}
    Status(ASTNode *nn) : n(nn) {}
  };



  class ASTNode : public Node {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ASTNode() {}



  virtual Status welcome(Visitor&) = 0;
  };


  class Symbol : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Symbol() {}

  string name;

  Symbol(string s) : name(s) {}
  };


  class ModuleSymbol : public Symbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ModuleSymbol() {}

  Module *module;

  ModuleSymbol(string s) : Symbol(s), module(0) {}
  };


  class ValuedSymbol : public Symbol {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ValuedSymbol() {}

  TypeSymbol *type;
  Expression *initializer;

  ValuedSymbol(string n, TypeSymbol *t, Expression *e)
    : Symbol(n), type(t), initializer(e) {}
  };


  class VariableSymbol : public ValuedSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    VariableSymbol() {}


  VariableSymbol(string n, TypeSymbol *t, Expression *e)
    : ValuedSymbol(n, t, e) {}
  };


  class ConstantSymbol : public VariableSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ConstantSymbol() {}


  ConstantSymbol(string n, TypeSymbol *t, Expression *i)
     : VariableSymbol(n, t, i) {}
  };


  class BuiltinConstantSymbol : public ConstantSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    BuiltinConstantSymbol() {}


  BuiltinConstantSymbol(string n, TypeSymbol *t, Expression *i)
     : ConstantSymbol(n, t, i) {}
  };


  class SignalSymbol : public ValuedSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    SignalSymbol() {}

  typedef enum { Input,Output,Inputoutput,Sensor,Return,Local,Trap,Unknown } kinds;
  int kind;
  FunctionSymbol *combine; // combining function, if any
  SignalSymbol *reincarnation; // the signal this is a reincarnation of, if any

  SignalSymbol(string n, TypeSymbol *t, kinds k, FunctionSymbol *f,
               Expression *e, SignalSymbol *r)
    : ValuedSymbol(n, t, e), kind(k), combine(f), reincarnation(r) {}
  };


  class BuiltinSignalSymbol : public SignalSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    BuiltinSignalSymbol() {}


  BuiltinSignalSymbol(string n, TypeSymbol *t, kinds k, FunctionSymbol *f)
    : SignalSymbol(n, t, k, f, NULL, NULL) {}
  };


  class TypeSymbol : public Symbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    TypeSymbol() {}


   TypeSymbol(string s) : Symbol(s) {}
  };


  class BuiltinTypeSymbol : public TypeSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    BuiltinTypeSymbol() {}


   BuiltinTypeSymbol(string s) : TypeSymbol(s) {}
  };


  class FunctionSymbol : public TypeSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    FunctionSymbol() {}

  vector<TypeSymbol*> arguments;
  TypeSymbol *result;

  FunctionSymbol(string s) : TypeSymbol(s), result(NULL) {}
  };


  class BuiltinFunctionSymbol : public FunctionSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    BuiltinFunctionSymbol() {}


  BuiltinFunctionSymbol(string s) : FunctionSymbol(s) {}
  };


  class ProcedureSymbol : public TypeSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ProcedureSymbol() {}

  vector<TypeSymbol*> reference_arguments;
  vector<TypeSymbol*> value_arguments;

  ProcedureSymbol(string s) : TypeSymbol(s) {}
  };


  class TaskSymbol : public ProcedureSymbol {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    TaskSymbol() {}


  TaskSymbol(string s) : ProcedureSymbol(s) {}
  };


  class SymbolTable : public ASTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  SymbolTable *parent;
  typedef vector<Symbol*> stvec;
  stvec symbols;

  SymbolTable() : parent(NULL) {}

  class const_iterator {
    stvec::const_iterator i;
  public:
    const_iterator(stvec::const_iterator ii) : i(ii) {}
    void operator ++(int) { i++; } // int argument denotes postfix
    void operator ++() { ++i; } // int argument denotes postfix
    bool operator !=(const const_iterator &ii) { return i != ii.i; }
    Symbol *operator *() { return *i; }
  };

  const_iterator begin() const { return const_iterator(symbols.begin()); }
  const_iterator end() const { return const_iterator(symbols.end()); }
  size_t size() const { return symbols.size(); }
  void clear() { symbols.clear(); }

  bool local_contains(const string) const;
  bool contains(const string) const;
  void enter(Symbol *);
  Symbol* get(const string);
  };


  class Expression : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Expression() {}

  TypeSymbol *type;

  Expression(TypeSymbol *t) : type(t) {}
  };


  class Literal : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Literal() {}

  string value;

  Literal(string v, TypeSymbol *t) : Expression(t), value(v) {}
  };


  class LoadVariableExpression : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    LoadVariableExpression() {}

  VariableSymbol *variable;

  LoadVariableExpression(VariableSymbol *v)
    : Expression(v->type), variable(v) {}
  };


  class LoadSignalExpression : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    LoadSignalExpression() {}

  SignalSymbol *signal;

  LoadSignalExpression(TypeSymbol *t, SignalSymbol *s)
    : Expression(t), signal(s) {}
  };


  class LoadSignalValueExpression : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    LoadSignalValueExpression() {}

  SignalSymbol *signal;
  
  LoadSignalValueExpression(SignalSymbol *s)
    : Expression(s->type), signal(s) {}
  };


  class UnaryOp : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    UnaryOp() {}

  string op;
  Expression *source;

  UnaryOp(TypeSymbol *t, string s, Expression *e)
    : Expression(t), op(s), source(e) {}
  };


  class BinaryOp : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    BinaryOp() {}

  string op;
  Expression *source1;
  Expression *source2;

  BinaryOp(TypeSymbol *t, string s, Expression *e1, Expression *e2)
    : Expression(t), op(s), source1(e1), source2(e2) {}
  };


  class FunctionCall : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    FunctionCall() {}

  FunctionSymbol *callee;
  vector<Expression*> arguments;

  FunctionCall(FunctionSymbol *s)
    : Expression(s->result), callee(s) {}
  };


  class Delay : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Delay() {}

  Expression *predicate;
  Expression *count;
  bool is_immediate;
  Counter *counter;

  Delay(TypeSymbol *t, Expression *e1, Expression *e2,
         bool i, Counter *c)
   : Expression(t), predicate(e1), count(e2), is_immediate(i), counter(c) {}
  };


  class CheckCounter : public Expression {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    CheckCounter() {}

  Counter *counter;
  Expression *predicate;

  CheckCounter(TypeSymbol *t, Counter *c, Expression *p )
    : Expression(t), counter(c), predicate(p) {}
  };


  class Module : public ASTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  ModuleSymbol *symbol;
  SymbolTable *types;
  SymbolTable *constants;
  SymbolTable *functions;
  SymbolTable *procedures;
  SymbolTable *tasks;
  SymbolTable *signals;
  SymbolTable *variables;
  vector<Counter*> counters;
  vector<InputRelation*> relations;
  ASTNode *body;
  
  Module() {}
  Module(ModuleSymbol *);
  ~Module();    
  };


  class InputRelation : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    InputRelation() {}


  };


  class Exclusion : public InputRelation {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Exclusion() {}

  vector<SignalSymbol *> signals;
  };


  class Implication : public InputRelation {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Implication() {}

  SignalSymbol *predicate;
  SignalSymbol *implication;

  Implication(SignalSymbol *ss1, SignalSymbol*ss2)
    : predicate(ss1), implication(ss2) {}
  };


  class Counter : public ASTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Counter() {}


  };


  class Modules : public ASTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Modules() {}

  SymbolTable module_symbols;
  vector<Module*> modules;

  void add(Module*);
  };


  class Statement : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Statement() {}


  };


  class BodyStatement : public Statement {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    BodyStatement() {}

  Statement *body;

  BodyStatement(Statement *s) : body(s) {}
  };


  class PredicatedStatement : public BodyStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    PredicatedStatement() {}

  Expression *predicate;

  PredicatedStatement(Statement *s, Expression *e)
    : BodyStatement(s), predicate(e) {}
  };


  class CaseStatement : public Statement {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  vector<PredicatedStatement *> cases;
  Statement *default_stmt;

  CaseStatement() : default_stmt(0) {}
  PredicatedStatement *newCase(Statement *s, Expression *e) {
    PredicatedStatement *ps = new PredicatedStatement(s, e);
    cases.push_back(ps);
    return ps;
  }
  };


  class StatementList : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    StatementList() {}

  vector<Statement *> statements;

  StatementList& operator <<(Statement *s) {
    assert(s);
    statements.push_back(s);
    return *this;
  }
  };


  class ParallelStatementList : public Statement  {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ParallelStatementList() {}

  vector<Statement *> threads;
  };


  class Nothing : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Nothing() {}


  };


  class Pause : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Pause() {}


  };


  class Halt : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Halt() {}


  };


  class Emit : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Emit() {}

  SignalSymbol *signal;
  Expression *value;
  bool unknown;

  Emit(SignalSymbol *s, Expression *e)
    : signal(s), value(e), unknown(false) {}
  };


  class Exit : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Exit() {}

  SignalSymbol *trap;
  Expression *value;

  Exit(SignalSymbol *t, Expression *e) : trap(t), value(e) {}
  };


  class Sustain : public Emit {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Sustain() {}


  Sustain(SignalSymbol *s, Expression *e) : Emit(s, e) {}
  };


  class Assign : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Assign() {}

  VariableSymbol *variable;
  Expression *value;

  Assign(VariableSymbol *v, Expression *e) : variable(v), value(e) {}
  };


  class ProcedureCall : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ProcedureCall() {}

  ProcedureSymbol *procedure;
  vector<VariableSymbol*> reference_args;
  vector<Expression*> value_args;

  ProcedureCall(ProcedureSymbol *ps) : procedure(ps) {}
  };


  class Present : public CaseStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Present() {}


  };


  class If : public CaseStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    If() {}


  };


  class Loop : public BodyStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Loop() {}


  Loop(Statement *s) : BodyStatement(s) {}
  };


  class Repeat : public Loop {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Repeat() {}

  Expression *count;
  bool is_positive;
  Counter *counter;

  Repeat(Statement *s, Expression *e, bool p, Counter *c)
    : Loop(s), count(e), is_positive(p), counter(c) {}
  };


  class Abort : public CaseStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Abort() {}

  Statement *body;
  bool is_weak;

  Abort(Statement *s, bool i) : body(s), is_weak(i) {}
  Abort(Statement *s, Expression *e, Statement *s1)
    : body(s), is_weak(false) {
    newCase(s1, e);
  }
  };


  class Await : public CaseStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Await() {}


  };


  class LoopEach : public PredicatedStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    LoopEach() {}


  LoopEach(Statement *s, Expression *e) : PredicatedStatement(s, e) {}
  };


  class Every : public PredicatedStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Every() {}


  Every(Statement *s, Expression *e) : PredicatedStatement(s, e) {}
  };


  class Suspend : public PredicatedStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Suspend() {}


  Suspend(Statement *s, Expression *e) : PredicatedStatement(s, e) {}
  };


  class DoWatching : public PredicatedStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    DoWatching() {}

  Statement *timeout;

  DoWatching(Statement *s1, Expression *e, Statement *s2)
    : PredicatedStatement(s1, e), timeout(s2) {}
  };


  class DoUpto : public PredicatedStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    DoUpto() {}


  DoUpto(Statement *s, Expression *e) : PredicatedStatement(s, e) {}
  };


  class TaskCall : public ProcedureCall {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    TaskCall() {}

  SignalSymbol *signal;
  Statement *body;

  TaskCall(TaskSymbol *ts) : ProcedureCall(ts), signal(0), body(0) {}
  };


  class Exec : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Exec() {}

  vector <TaskCall *> calls;
  };


  class ScopeStatement : public BodyStatement {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ScopeStatement() {}

   SymbolTable *symbols;
  };


  class Trap : public ScopeStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Trap() {}

  vector<PredicatedStatement *> handlers;

  PredicatedStatement* newHandler(Expression *e, Statement *s) {
    PredicatedStatement *ps = new PredicatedStatement(s, e);
    handlers.push_back(ps);
    return ps;
  }
  };


  class Signal : public ScopeStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Signal() {}


  };


  class Var : public ScopeStatement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Var() {}


  };


  class StartCounter : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    StartCounter() {}

  Counter *counter;
  Expression *count;

  StartCounter(Counter *c, Expression *i): counter(c), count(i) {}
  };


  class Renaming : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Renaming() {}

  string old_name;

Renaming(string s) : old_name(s) {}
  };


  class TypeRenaming : public Renaming {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    TypeRenaming() {}

  TypeSymbol *new_type;

  TypeRenaming(string s, TypeSymbol *t) : Renaming(s), new_type(t) {}
  };


  class ConstantRenaming : public Renaming {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ConstantRenaming() {}

  Expression *new_value;

  ConstantRenaming(string s, Expression *e) : Renaming(s), new_value(e) {}
  };


  class FunctionRenaming : public Renaming {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    FunctionRenaming() {}

  FunctionSymbol *new_func;

  FunctionRenaming(string s, FunctionSymbol *f) : Renaming(s), new_func(f) {}
  };


  class ProcedureRenaming : public Renaming {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ProcedureRenaming() {}

  ProcedureSymbol *new_proc;

  ProcedureRenaming(string s, ProcedureSymbol *p)
    : Renaming(s), new_proc(p) {}
  };


  class SignalRenaming : public Renaming {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    SignalRenaming() {}

  SignalSymbol *new_sig;

  SignalRenaming(string s, SignalSymbol *ss) : Renaming(s), new_sig(ss) {}
  };


  class Run : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Run() {}

  string old_name;
  string new_name;
  vector<TypeRenaming *> types;
  vector<ConstantRenaming *> constants;
  vector<FunctionRenaming *> functions;
  vector<ProcedureRenaming *> procedures;
  vector<ProcedureRenaming *> tasks;
  vector<SignalRenaming *> signals;
  SymbolTable *signalScope;

  Run(string s, SymbolTable *ss) : old_name(s), new_name(s), signalScope(ss)
    {}
  };


  class IfThenElse : public Statement {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    IfThenElse() {}

  Expression *predicate;
  Statement *then_part;
  Statement *else_part;

  IfThenElse(Expression *e) : predicate(e) , then_part(0), else_part(0) {}
  IfThenElse(Expression *e, Statement *s1, Statement *s2)
    : predicate(e) , then_part(s1), else_part(s2) {}
  };


  class GRCNode : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    GRCNode() {}

  vector<GRCNode*> predecessors;
  vector<GRCNode*> successors;
  vector<GRCNode*> dataPredecessors;
  vector<GRCNode*> dataSuccessors;

  virtual Status welcome(Visitor&) = 0;

  GRCNode& operator >>(GRCNode*);
  GRCNode& operator <<(GRCNode*);
  typedef map<GRCNode *, int> NumMap;
  int enumerate(NumMap &, std::set<GRCNode *> &, int);
  };


  class GRCSTNode : public GRCNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    GRCSTNode() {}

  STNode *st;

  GRCSTNode(STNode *s) : st(s) {}
  };


  class EnterGRC : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    EnterGRC() {}


  };


  class ExitGRC : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    ExitGRC() {}


  };


  class Nop : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  int type;
  int code;
  string body;

  Nop(): type(0), code(0) {}

  int isflowin() { return type == 1;}
  void setflowin() { type = 1;}
  // a shorcut Nop gives up flow to child 0
  int isshortcut() { return type == 2;}
  void setshortcut() { type = 2;}
  };


  class DefineSignal : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    DefineSignal() {}

  SignalSymbol *signal;
  bool is_surface;

  DefineSignal(SignalSymbol *s, bool ss) : signal(s), is_surface(ss) {}
  };


  class Switch : public GRCSTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Switch() {}


  Switch(STNode *s) : GRCSTNode(s) {}
  };


  class Test : public GRCSTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Test() {}

  Expression *predicate;
  
  Test(STNode *s, Expression *e) : GRCSTNode(s), predicate(e) {}
  };


  class STSuspend : public GRCSTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    STSuspend() {}


  STSuspend(STNode *s) : GRCSTNode(s) {}
  };


  class Fork : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  Sync* sync;

  Fork() : sync(0) {}
  Fork(Sync* sync) : sync(sync) {}
  };


  class Sync : public GRCSTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Sync() {}

 
  Sync(STNode *s) : GRCSTNode(s) {}
  };


  class Terminate : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Terminate() {}

  int code;
  int index;

  Terminate(int c, int i) : code(c), index(i) {}
  };


  class Action : public GRCNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Action() {}

  Statement *body;

  Action(Statement *s) : body(s) {}
  };


  class Enter : public GRCSTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    Enter() {}


  Enter(STNode *s) : GRCSTNode(s) {}
  };


  class STNode : public ASTNode {
    public:
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  STNode *parent;
  vector<STNode*> children;

  STNode() : parent(0) {}
  virtual Status welcome(Visitor&) = 0;

  STNode& operator >>(STNode*);
  typedef map<STNode *, int> NumMap;
  int enumerate(NumMap &, std::set<STNode*> &visited, int);
  };


  class STexcl : public STNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    STexcl() {}


  };


  class STpar : public STNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    STpar() {}


  };


  class STref : public STNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  int type;

  STref(): type(0) {}

  int isabort() { return type == 1;}
  void setabort() { type = 1;}
  int issuspend() { return type == 2;}
  void setsuspend() { type = 2;}
  };


  class STleaf : public STNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    
  int type;

  STleaf(): type(0) {}
 
  int isfinal() { return type == 1;}
  void setfinal() { type = 1;}
  };


  class GRCgraph : public ASTNode {
    
    IRCLASSDEFS;
  public:
    Status welcome(Visitor&);
    
    void read(XMListream &);
    void write(XMLostream &) const;
    GRCgraph() {}

  STNode *selection_tree;
  GRCNode *control_flow_graph;

  GRCgraph(STNode *st, GRCNode *cfg)
     : selection_tree(st), control_flow_graph(cfg) {}

  int enumerate(GRCNode::NumMap &, STNode::NumMap &, int max = 1);
  };


  class Visitor {
  public:
  virtual ~Visitor() {}

  virtual Status visit(ModuleSymbol& n) { assert(0); return Status(); }
  virtual Status visit(VariableSymbol& n) { assert(0); return Status(); }
  virtual Status visit(ConstantSymbol& n) { assert(0); return Status(); }
  virtual Status visit(BuiltinConstantSymbol& n) { assert(0); return Status(); }
  virtual Status visit(SignalSymbol& n) { assert(0); return Status(); }
  virtual Status visit(BuiltinSignalSymbol& n) { assert(0); return Status(); }
  virtual Status visit(TypeSymbol& n) { assert(0); return Status(); }
  virtual Status visit(BuiltinTypeSymbol& n) { assert(0); return Status(); }
  virtual Status visit(FunctionSymbol& n) { assert(0); return Status(); }
  virtual Status visit(BuiltinFunctionSymbol& n) { assert(0); return Status(); }
  virtual Status visit(ProcedureSymbol& n) { assert(0); return Status(); }
  virtual Status visit(TaskSymbol& n) { assert(0); return Status(); }
  virtual Status visit(SymbolTable& n) { assert(0); return Status(); }
  virtual Status visit(Literal& n) { assert(0); return Status(); }
  virtual Status visit(LoadVariableExpression& n) { assert(0); return Status(); }
  virtual Status visit(LoadSignalExpression& n) { assert(0); return Status(); }
  virtual Status visit(LoadSignalValueExpression& n) { assert(0); return Status(); }
  virtual Status visit(UnaryOp& n) { assert(0); return Status(); }
  virtual Status visit(BinaryOp& n) { assert(0); return Status(); }
  virtual Status visit(FunctionCall& n) { assert(0); return Status(); }
  virtual Status visit(Delay& n) { assert(0); return Status(); }
  virtual Status visit(CheckCounter& n) { assert(0); return Status(); }
  virtual Status visit(Module& n) { assert(0); return Status(); }
  virtual Status visit(Exclusion& n) { assert(0); return Status(); }
  virtual Status visit(Implication& n) { assert(0); return Status(); }
  virtual Status visit(Counter& n) { assert(0); return Status(); }
  virtual Status visit(Modules& n) { assert(0); return Status(); }
  virtual Status visit(PredicatedStatement& n) { assert(0); return Status(); }
  virtual Status visit(StatementList& n) { assert(0); return Status(); }
  virtual Status visit(ParallelStatementList& n) { assert(0); return Status(); }
  virtual Status visit(Nothing& n) { assert(0); return Status(); }
  virtual Status visit(Pause& n) { assert(0); return Status(); }
  virtual Status visit(Halt& n) { assert(0); return Status(); }
  virtual Status visit(Emit& n) { assert(0); return Status(); }
  virtual Status visit(Exit& n) { assert(0); return Status(); }
  virtual Status visit(Sustain& n) { assert(0); return Status(); }
  virtual Status visit(Assign& n) { assert(0); return Status(); }
  virtual Status visit(ProcedureCall& n) { assert(0); return Status(); }
  virtual Status visit(Present& n) { assert(0); return Status(); }
  virtual Status visit(If& n) { assert(0); return Status(); }
  virtual Status visit(Loop& n) { assert(0); return Status(); }
  virtual Status visit(Repeat& n) { assert(0); return Status(); }
  virtual Status visit(Abort& n) { assert(0); return Status(); }
  virtual Status visit(Await& n) { assert(0); return Status(); }
  virtual Status visit(LoopEach& n) { assert(0); return Status(); }
  virtual Status visit(Every& n) { assert(0); return Status(); }
  virtual Status visit(Suspend& n) { assert(0); return Status(); }
  virtual Status visit(DoWatching& n) { assert(0); return Status(); }
  virtual Status visit(DoUpto& n) { assert(0); return Status(); }
  virtual Status visit(TaskCall& n) { assert(0); return Status(); }
  virtual Status visit(Exec& n) { assert(0); return Status(); }
  virtual Status visit(Trap& n) { assert(0); return Status(); }
  virtual Status visit(Signal& n) { assert(0); return Status(); }
  virtual Status visit(Var& n) { assert(0); return Status(); }
  virtual Status visit(StartCounter& n) { assert(0); return Status(); }
  virtual Status visit(TypeRenaming& n) { assert(0); return Status(); }
  virtual Status visit(ConstantRenaming& n) { assert(0); return Status(); }
  virtual Status visit(FunctionRenaming& n) { assert(0); return Status(); }
  virtual Status visit(ProcedureRenaming& n) { assert(0); return Status(); }
  virtual Status visit(SignalRenaming& n) { assert(0); return Status(); }
  virtual Status visit(Run& n) { assert(0); return Status(); }
  virtual Status visit(IfThenElse& n) { assert(0); return Status(); }
  virtual Status visit(EnterGRC& n) { assert(0); return Status(); }
  virtual Status visit(ExitGRC& n) { assert(0); return Status(); }
  virtual Status visit(Nop& n) { assert(0); return Status(); }
  virtual Status visit(DefineSignal& n) { assert(0); return Status(); }
  virtual Status visit(Switch& n) { assert(0); return Status(); }
  virtual Status visit(Test& n) { assert(0); return Status(); }
  virtual Status visit(STSuspend& n) { assert(0); return Status(); }
  virtual Status visit(Fork& n) { assert(0); return Status(); }
  virtual Status visit(Sync& n) { assert(0); return Status(); }
  virtual Status visit(Terminate& n) { assert(0); return Status(); }
  virtual Status visit(Action& n) { assert(0); return Status(); }
  virtual Status visit(Enter& n) { assert(0); return Status(); }
  virtual Status visit(STexcl& n) { assert(0); return Status(); }
  virtual Status visit(STpar& n) { assert(0); return Status(); }
  virtual Status visit(STref& n) { assert(0); return Status(); }
  virtual Status visit(STleaf& n) { assert(0); return Status(); }
  virtual Status visit(GRCgraph& n) { assert(0); return Status(); }
  };

}

#endif

